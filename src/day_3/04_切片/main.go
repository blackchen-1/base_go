package main

import "fmt"
import "reflect"

/*
	切片知识点:
	注意:
		1. 切片的组成: 数组的起始地址 切片的长度 切片的容量 
		2. 切片取值特点: 左闭右开
		3. 切片是数组的引用。(切片若声明但未初始化,底层是没有空间的，不开辟数组的。)(当切片声明并初始化时, 底层开辟了一个数组)
		4. 切片的长度 = 切片现有的元素个数
		5. 切片的容量 = 原切片(原底层数组)的总个数 - 起始索引值
		6. 切片和数组的区别: 切片没有固定长度。而数组需要有固定长度
*/

// 1. 基于数组，创建切片(用于理解切片的原理)
func slice_init_1() {
	
	var arr = [5]int{22, 23, 24, 25, 26} // 声明并初始化数组
	
	// 1. 基于数组创建切片s1
	s1 := arr[:]
	fmt.Println(s1, reflect.TypeOf(s1), len(s1), cap(s1))
	
	// 2. 基于切片，再切出一个切片
	s2 := s1[2:4] // 这里的取值是根据索引, 从s1的元素中进行取值
	fmt.Println(s2, len(s2), cap(s2)) // len是现有的元素个数(索引2和索引3的值)。 cap是共同引用的数组的总元素个数 - (当前切片的起始索引的值，在引用数组中的索引值) // 长度:2 容量：5-2=3

	// 3. 基于切片, 再切出一个切片
	s3 := s2[0:1] // 这里的取值是从根据索引，从s2的元素中进行取值
	fmt.Println(s3, len(s3), cap(s3)) // 长度是1， 容量:5 - 2 = 3(因为这里的索引0，在原数组中的值是24，索引为2。原数组的元素总个数是5.所以 5-2=3)

	// 4. 通过切片3改值。数组和其它两个切片对应位置的值也会发生改变(因为本质是3个切片,引用(共享)了一个数组)
	s3[0] = 666
	fmt.Println("arr:", arr)
	fmt.Println("s1:", s1)
	fmt.Println("s2:", s2)
	fmt.Println("s3", s3)
}

// 2. 切片的常规声明并初始化
// 注: 直接声明并初始化一个切片,其本质是在底层声明并初始化了一个数组
func slice_init_2() {
	var s = []int{1, 2, 3, 4, 5}
	s1 := s[1:4] // [2 3 4] 取不到索引4,是因为切片的左闭右开原则
	fmt.Println(s1, len(s1), cap(s1)) // [2 3 4], len: 3, cap: 4

	s2 := s1[1:2] // 根据索引，取s1中元素值: [3], len: 1, cap: 5-2=3
	fmt.Println(s2, len(s2), cap(s2))

}

// 切片练习()
func slice_practice() {

}

func main() {
	// slice_init_1()
	slice_init_2()
}