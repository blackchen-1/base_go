package main

import "fmt"

// 1. new函数
func new_use(){
	// （1）. 首先一般声明指针并初始化的流程
	var x int = 10 // 这里声明并初始化x这个变量， 会开辟一块空间存储10这个值
	y := &x // 这里声明并初始化y这个变量。这时的y指针会开辟一块空间,存储x的地址
	fmt.Println(*y) // 通过取值操作,输出x的值。 到此是对指针y的初始化赋值的基本流程
	
	// // ( 2 ) 其次, 使用一个错误用例。 说一下错误的声明但未初始化,赋值指针的操作
	// var y1 *int // 这里进行声明指针变量y1。 但此时的y1这个指针是没有被开辟内存的。
	// // 不同于值类型(不做初始化赋值的话，但有默认值),引用类型不做初始化流程是没有默认值的
	// // 并且用一个直观比较的说法, y1在未初始化时, 就相当于C中 y1 = NULL 的操作（而go中y1是nil）。 不能对变量为NULL的指针,直接赋一个值的操作。会崩溃
	// fmt.Println(y1) // nil
	// *y1 = 10 // 没有初始化的y1(即此时没有开辟内存空间的指针y)是没办法直接存储一个值的,只能存储一个变量地址
	// fmt.Println(*y1) // panic : 原因参照上面的流程

	// (3). 相对于(1) 和 (2)的过程， 就使new函数应运而生
	// new 加入了(1)的初始化指针流程, 避免了（2） 中未对指针做初始化，便给指针赋值的操作
	var y1 = new(int) // 该操作解析: 开辟了一块内存, 该内存的地址存的值,则是int的默认值0。并将内存地址赋予指针y1。 完成了初始化并对指针赋值的操作
	fmt.Printf("addr_y1 = %p\naddr_&y1 = %p\n", y1, &y1) // 这里的y1就是开辟用于存储默认值0的内存地址。 &y1是y1本身的地址
	fmt.Println(*y1)
}

func main() {
	new_use()
}
